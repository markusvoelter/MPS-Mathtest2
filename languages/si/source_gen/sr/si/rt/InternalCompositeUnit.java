package sr.si.rt;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class InternalCompositeUnit {
  private Map<SNode, Integer> elements = MapSequence.fromMap(new HashMap<SNode, Integer>());

  public InternalCompositeUnit() {
  }

  private InternalCompositeUnit cloneIt() {
    InternalCompositeUnit res = new InternalCompositeUnit();
    MapSequence.fromMap(res.elements).putAll(elements);
    return res;
  }

  public void addInternal(SNode unit, int exp) {
    if (!(MapSequence.fromMap(elements).containsKey(unit))) {
      MapSequence.fromMap(elements).put(unit, exp);
    } else {
      MapSequence.fromMap(elements).put(unit, MapSequence.fromMap(elements).get(unit) + exp);
    }
  }

  public InternalCompositeUnit add(InternalCompositeUnit other) {
    InternalCompositeUnit res = this.cloneIt();
    for (SNode unit : SetSequence.fromSet(MapSequence.fromMap(other.elements).keySet())) {
      res.addInternal(unit, MapSequence.fromMap(other.elements).get(unit));
    }
    return res;
  }

  public InternalCompositeUnit add(InternalCompositeUnit other, int exp) {
    InternalCompositeUnit res = this.cloneIt();
    for (SNode unit : SetSequence.fromSet(MapSequence.fromMap(other.elements).keySet())) {
      res.addInternal(unit, MapSequence.fromMap(other.elements).get(unit) * exp);
    }
    return res;
  }

  public InternalCompositeUnit inverse() {
    final InternalCompositeUnit res = this.cloneIt();
    SetSequence.fromSet(MapSequence.fromMap(res.elements).keySet()).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        MapSequence.fromMap(res.elements).put(it, -1 * MapSequence.fromMap(res.elements).get(it));
      }
    });
    return res;
  }

  public InternalCompositeUnit normalize() {
    InternalCompositeUnit res = new InternalCompositeUnit();
    for (SNode u : SetSequence.fromSet(MapSequence.fromMap(elements).keySet())) {
      if (MapSequence.fromMap(elements).get(u) != 0) {
        MapSequence.fromMap(res.elements).put(u, MapSequence.fromMap(elements).get(u));
      }
    }
    return res;
  }

  public boolean isEmpty() {
    return (int) MapSequence.fromMap(elements).count() == 0;
  }

  public SNode toUnit() {
    SNode res = SConceptOperations.createNewNode("sr.si.structure.CompositeUnitFraction", null);
    for (SNode u : SetSequence.fromSet(MapSequence.fromMap(elements).keySet())) {
      if (u == SConceptOperations.findConceptDeclaration("sr.si.structure.NoUnit")) {
        continue;
      }
      int exp = MapSequence.fromMap(elements).get(u);
      boolean isNegative = exp < 0;
      for (int i = 0; i < Math.abs(exp); i++) {
        if (isNegative) {
          ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(res, "denominator", true), "factors", true)).addElement(SConceptOperations.createNewNode(NameUtil.nodeFQName(u), null));
        } else if (exp > 0) {
          ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(res, "numerator", true), "factors", true)).addElement(SConceptOperations.createNewNode(NameUtil.nodeFQName(u), null));
        }
      }
    }
    if (ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(res, "denominator", true), "factors", true)).isEmpty()) {
      if ((int) ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(res, "numerator", true), "factors", true)).count() == 0) {
        return SConceptOperations.createNewNode("sr.si.structure.NoUnit", null);
      }
      if ((int) ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(res, "numerator", true), "factors", true)).count() == 1) {
        return ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(res, "numerator", true), "factors", true)).first();
      }
      return SLinkOperations.getTarget(res, "numerator", true);
    } else {
      return res;
    }
  }

  public String toString() {
    StringBuffer bf = new StringBuffer();
    for (SNode u : SetSequence.fromSet(MapSequence.fromMap(elements).keySet())) {
      bf.append(SPropertyOperations.getString(u, "name") + "," + MapSequence.fromMap(elements).get(u) + ";");
    }
    return bf.toString();
  }
}
