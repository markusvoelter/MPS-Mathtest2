package sr.functionblocks.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import sr.functionblocks.behavior.JFunctionCall_Behavior;
import sr.functionblocks.behavior.Symbol_Behavior;
import jetbrains.mps.smodel.SModelUtil_new;

public class check_JFunctionCall_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_JFunctionCall_NonTypesystemRule() {
  }

  public void applyRule(final SNode call, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    if (!(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(SLinkOperations.getTarget(call, "function", false), "testBlock", true), "tests", true)).all(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SPropertyOperations.getBoolean(it, "isOk");
      }
    }))) {
      {
        MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(call, "in-IDE tests are broken for this function", "r:91f2afc4-82b5-4f5c-9baa-b5e3bcea0af6(sr.functionblocks.typesystem)", "3400456754308844385", null, errorTarget);
      }
    }
    for (final SNode es : ListSequence.fromList(JFunctionCall_Behavior.call_requiredInputSymbols_3006277004735647967(call))) {
      boolean found = false;
      for (SNode setref : ListSequence.fromList(SLinkOperations.getTargets(call, "values", true))) {
        SNode set = SLinkOperations.getTarget(setref, "valueSet", false);
        if (ListSequence.fromList(SLinkOperations.getTargets(set, "values", true)).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SLinkOperations.getTarget(it, "symbol", false) == es;
          }
        })) {
          found = true;
          break;
        }
      }
      if (!(found)) {
        {
          MessageTarget errorTarget = new NodeMessageTarget();
          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(call, "no value provided for symbol " + Symbol_Behavior.call_qualifiedName_3006277004735674470(es), "r:91f2afc4-82b5-4f5c-9baa-b5e3bcea0af6(sr.functionblocks.typesystem)", "3893397118698826637", null, errorTarget);
        }
      }
    }
  }

  public String getApplicableConceptFQName() {
    return "sr.functionblocks.structure.JFunctionCall";
  }

  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    {
      boolean b = SModelUtil_new.isAssignableConcept(argument.getConceptFqName(), this.getApplicableConceptFQName());
      return new IsApplicableStatus(b, null);
    }
  }

  public boolean overrides() {
    return false;
  }
}
